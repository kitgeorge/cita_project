#include "mestel.hpp"
#include "dehnen_df.hpp"

namespace df {




/**
 * Constructs a Dehnen (1999) DF for a mestel potential, tapered in R
 *
 *
 *
 *
 * @note NormDehnenDF is used, but is multiplied by inner and outer
 * tapers. This means that the resulting DF will have a maximum value
 * <= 1. Ideally for fastest sampling under our methods, you want
 * maximum value = 1, but that doesn't appear easily feasible here.
 *
 * @note Mestel density profile is only a target. Currently the DF
 * we'll obtain will not accurately reproduce it. This will be 
 * sufficient for playing around with the N-body, but the background
 * potential (Mestel) and the collective effects (DF - initial DF)
 * will be distinct. Later we'll use the algorithm in Dehnen (1999)
 * (or perhaps use his full sampling code) to mitigate the 
 * inaccuracy.
 * */
class TaperedDF {
    const double v_c;
    const double R_0;
    const potential::AxsymFuncs mestel_potential;
    public:
        /// Bounds in E over which to sample
        const std::array<double, 2> E_bounds;
        /// Bounds in L over which to sample
        const std::array<double, 2> L_bounds;
    private:
        const std::function<double(double, double)> dehnen_df;

        const std::array<double, 2> taper_radii;
        const std::array<double, 2> taper_indices;
    
        std::array<double, 2> 
        getEBounds(std::array<double, 2> cutoff_radii) const;
        std::array<double, 2>
        getLBounds(std::array<double, 2> cutoff_radii) const;

        std::function<double(double, double)>
        calculateDehnenDF(double active_fraction,
                          const std::function<double(double)>& target_Q)
                          const;
                          
        double innerTaper(double L) const;
        double outerTaper(double L) const;
        std::function<double(double, double)>
        calculateTaperedDF() const;

        double tdfFunction(double E, double L);

    public:
        /**
         * Constructor, fully calculates DF and sampling bounds
         *
         * @param v_c_ circular orbit speed of Mestel potential
         * @param R_0_ reference radius for tapering (see Dootson 2022)
         * @param active_fraction fraction of potential generated by 
         * @param taper_radii_ R_i and R_o for tapers (in units of R_0)
         * @param taper_indices_ nu_t and mu_t indices for inner and outer
         * tapers respectively
         * @param cutoff_radii determines bounds in E and L for sampling
         * DF (pre-taper)
         * @param target_Q target velocity dispersion function (of R) is calculated
         * from target density profile (Mestel) and target_Q (functions of R)
         */
        TaperedDF(double v_c_, double R_0_, double active_fraction,
                  std::array<double, 2> taper_radii_, 
                  std::array<double, 2> taper_indices_,
                  std::array<double, 2> cutoff_radii,
                  const std::function<double(double)>& target_Q);
        /// Copy constructor
        TaperedDF(const TaperedDF& old);

        /// Tapered DF, f(E, L), to be sampled
        std::function<double(double, double)> getTaperedDF() const;
}


}